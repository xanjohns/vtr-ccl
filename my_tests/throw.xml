<!--

  !!SAVED PIECE, BY PEACE VERSION OF DSP SLICE!!
  This architecture file is an approximation of the xilinx 7 series chip set. It's main purpose is to verify VPR's ability to
  accommodate xilinx specific routing (i.e. differing wire lengths and frequencies in the horizontal/vertical directions, differing chanel widths,
  and diagonal wire segments). Given that this architectures primary function is to test xilinx specific routing, the architecture includes only
  a simplified version of the Xilinx CLB that excludes carry logic. f4pga/symbiflow's arch.timing.xml and VTR's k6_N10_40nm.xml were pulled from to create
  this architecture description.

  - 40 nm technology
  - General purpose logic block excluding carry.
  - Routing architecture: fc_in = 0.15, Fc_out = 0.1
;
  Authors: Xan Johnson, Joshua Fife, Jeff Goeders
-->
<architecture>
  <!-- ODIN II specific config begins -->
  <!--
         Given that basic LUTs, I/Os, and flip-flops already have special structures in
     blif (.names, .input, .output, and .latch) that describe them and that this arch
     contains CLB logic blocks only, no special models are needed for this architecture.
    -->
  <models/>
  <tiles>
    <tile name="io" area="0">
      <sub_tile name="io" capacity="8">
        <equivalent_sites>
          <site pb_type="io" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="outpad" num_pins="1"/>
        <output name="inpad" num_pins="1"/>
        <clock name="clock" num_pins="1"/>
        <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10"/>
        <pinlocations pattern="custom">
          <loc side="left">io.outpad io.inpad io.clock</loc>
          <loc side="top">io.outpad io.inpad io.clock</loc>
          <loc side="right">io.outpad io.inpad io.clock</loc>
          <loc side="bottom">io.outpad io.inpad io.clock</loc>
        </pinlocations>
      </sub_tile>
    </tile>
    <tile name="clb">
      <sub_tile capacity="1" name="clb">
        <!-- Sub Tile Inputs -->
        <clock name="CLK" num_pins="1"/>
        <input name="I" num_pins="56"/>
        <output name="O" num_pins="24"/>
        <fc in_type="frac" in_val="0" out_type="frac" out_val="0">
          <fc_override port_name="cout" fc_type="frac" fc_val="0"/> 
          <fc_override segment_name="len1_x" fc_type="frac" fc_val="0.25"/> 
          <fc_override segment_name="len1_y" fc_type="frac" fc_val="0.25"/> 
          <fc_override segment_name="len2_x" fc_type="frac" fc_val="0.25"/> 
          <fc_override segment_name="len2_y" fc_type="frac" fc_val="0.25"/> 
          <!-- !! using fc override we can specify that only L1 and L2 have fc. CONFIRMED -->
          <!-- the above give a width of 126 -->

          <!-- the bellow gives a width of 90  -->
           <!-- you can use a conjunction  of ports with segments to give seperate fc in and out.
          i.e. port="my out" segment="len6" -->
          <fc_override segment_name="len1D_x" fc_type="frac" fc_val="0.25"/> 
          <fc_override segment_name="len1D_y" fc_type="frac" fc_val="0.25"/> 
          <fc_override segment_name="2len1D_x" fc_type="frac" fc_val="0.25"/> 
          <fc_override segment_name="2len1D_y" fc_type="frac" fc_val="0.25"/> 
           
          <fc_override segment_name="3len1D_x" fc_type="frac" fc_val="0.25"/> 
          <fc_override segment_name="3len1D_y" fc_type="frac" fc_val="0.25"/> 
          <fc_override segment_name="4len1D_x" fc_type="frac" fc_val="0.25"/> 
          <fc_override segment_name="4len1D_y" fc_type="frac" fc_val="0.25"/> 
        </fc>
        <equivalent_sites>
          <site pb_type="clb" pin_mapping="direct">
          </site>
        </equivalent_sites>
      </sub_tile>
      <switchblock_locations pattern="all"/>
    </tile>

    <!-- The interconn for DSP come from symbiflow -->
    <tile name="DSP48E1_VPR" height="5" width="1" area="253779">
      <clock name="CLK" num_pins="1"/>
      <input name="A" num_pins="30"/>
      <input name="ACIN" num_pins="30"/>
      <input name="ALUMODE" num_pins="4"/>
      <input name="B" num_pins="18"/>
      <input name="BCIN" num_pins="18"/>
      <input name="C" num_pins="48"/>
      <input name="CARRYCASCIN" num_pins="1"/>
      <input name="CARRYIN" num_pins="1"/>
      <input name="CARRYINSEL" num_pins="3"/>
      <input name="CEA1" num_pins="1"/>
      <input name="CEA2" num_pins="1"/>
      <input name="CEAD" num_pins="1"/>
      <input name="CEALUMODE" num_pins="1"/>
      <input name="CEB1" num_pins="1"/>
      <input name="CEB2" num_pins="1"/>
      <input name="CEC" num_pins="1"/>
      <input name="CECARRYIN" num_pins="1"/>
      <input name="CECTRL" num_pins="1"/>
      <input name="CED" num_pins="1"/>
      <input name="CEINMODE" num_pins="1"/>
      <input name="CEM" num_pins="1"/>
      <input name="CEP" num_pins="1"/>
      <input name="D" num_pins="25"/>
      <input name="INMODE" num_pins="5"/>
      <!-- <input name="MULTSIGNIN" num_pins="1"/> -->
      <input name="OPMODE" num_pins="7"/>
      <input name="PCIN" num_pins="48"/>
      <input name="RSTA" num_pins="1"/>
      <input name="RSTALLCARRYIN" num_pins="1"/>
      <input name="RSTALUMODE" num_pins="1"/>
      <input name="RSTB" num_pins="1"/>
      <input name="RSTC" num_pins="1"/>
      <input name="RSTCTRL" num_pins="1"/>
      <input name="RSTD" num_pins="1"/>
      <input name="RSTINMODE" num_pins="1"/>
      <input name="RSTM" num_pins="1"/>
      <input name="RSTP" num_pins="1"/>
      <output name="ACOUT"          num_pins="30"/>
      <output name="BCOUT"          num_pins="18"/>
      <output name="CARRYCASCOUT"   num_pins="1"/>
      <output name="CARRYOUT"       num_pins="4"/>
      <output name="MULTSIGNOUT"    num_pins="1"/>
      <output name="OVERFLOW"       num_pins="1"/>
      <output name="P"              num_pins="48"/>
      <output name="PATTERNBDETECT" num_pins="1"/>
      <output name="PATTERNDETECT"  num_pins="1"/>
      <output name="PCOUT"          num_pins="48"/>
      <output name="UNDERFLOW"      num_pins="1"/>
    </tile>
  </tiles>
  <!-- ODIN II specific config ends -->

  <!-- Physical descriptions begin -->
  <layout>
    <auto_layout aspect_ratio="1.0">
      <!--Perimeter of 'io' blocks with 'EMPTY' blocks at corners-->
      <perimeter type="io" priority="100"/>
      <corners type="EMPTY" priority="101"/>
      <!--Fill with 'clb'-->
      <fill type="clb" priority="10"/>
    </auto_layout>
  </layout>
  <device>
   <!-- The  values bellow (sizing and area) are pulled from the k6_N10_40nm arch. -->
    <sizing R_minW_nmos="8926" R_minW_pmos="16067"/>
    <area grid_logic_tile_area="0"/>

    <chan_width_distr>
      <x distr="uniform" peak="0.652632"/>
      <y distr="uniform" peak="1.000000"/>
    </chan_width_distr>
    <switch_block type="custom"/>
    <connection_block input_switch_name="ipin_cblock"/>
  </device>

  <switchlist>

    <!--the following muxes for unidirectional wires are pulled from k6_N10_40nm -->
    <switch type="mux" name="0" R="551" Cin=".77e-15" Cout="4e-15" Tdel="58e-12" mux_trans_size="2.630740" buf_size="27.645901"/>
    <switch type="mux" name="ipin_cblock" R="2231.5" Cout="0." Cin="1.47e-15" Tdel="7.247000e-11" mux_trans_size="1.222260" buf_size="auto"/>
    <switch type="short" name="electrical_short2" R="0" Cin="0" Tdel="0"/>
  </switchlist>

  <segmentlist>
        <!--- The following segment data is pulled from Table 1 of the NetCraker paper by Morten B. Petersen,
    Stefan Nikolić and Mirjana Stojilović: see https://dl.acm.org/doi/10.1145/3431920.3439285. Frequencies
    are calculated by dividing each wire segments count in the horizontal/vertical direction
    by the total width/hight of the architecture -->

    <!-- TODO: To more accurately approximate the seven series, support for both unidirectional and
    bidirectional segments within the same segmentlist is needed. For now we declare all segments as
    unidirectional -->

    <!-- TODO: For proper timing, Xilinx specific values for Rmetal and Cmetal are required.
    For now we approximate using the values given in the k6_N10_40nm arch -->

        <segment axis="x" name="len1_x" freq="0.112903" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 1</sb>
            <cb type="pattern">1</cb>
        </segment>
        <segment axis="y" name="len1_y" freq="0.073684" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 1</sb>
            <cb type="pattern">1</cb>
        </segment>

        <segment axis="y" name="stub" freq="0.088047" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
          <mux name="0"/>
          <sb type="pattern">1 1</sb>
          <cb type="pattern">1</cb>
      </segment>
      <segment axis="x" name="stub_dud" freq="0.000000" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
        <mux name="0"/>
        <sb type="pattern">1 1</sb>
        <cb type="pattern">1</cb>
    </segment>

        <segment axis="x" name="len2_x" freq="0.129031" length="2" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 1</sb>
            <cb type="pattern">1 1</cb>
        </segment>

        <segment axis="y" name="len2_y" freq="0.084210" length="2" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 1</sb>
            <cb type="pattern">1 1</cb>
        </segment>

        <segment axis="x" name="len4_x" freq="0.225807" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 0 0 1</sb>
            <cb type="pattern">1 0 0 1</cb>
        </segment>
        <segment axis="y" name="len4_y" freq="0" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
          <mux name="0"/>
          <sb type="pattern">1 0 0 0 1</sb>
          <cb type="pattern">1 0 0 1</cb>
        </segment>


    <!-- 12.5% of horizontal len4 wires have the following unique sb pattern -->
    <segment axis="x" name="len4_stub" freq="0.032258" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 1 1 0 1</sb>
            <cb type="pattern">1 1 0 1</cb>
        </segment>


        <!-- No length 6 horizontal chanels -->
    <!-- VPR throws an error if this segment in the x direction with zero frequency is not included -->
    <segment axis="x" name="len6_x" freq="0.000000" length="6" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 1 1 0 0 1 1</sb>
            <cb type="pattern">1 1 0 0 1 1</cb>
        </segment>
        <segment axis="y" name="len6_y" freq="0.189475" length="6" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 0 0 0 0 1</sb>
            <cb type="pattern">1 0 0 0 0 1</cb>
        </segment>

    <!-- 25% of len6 vertical wires have a unique sb pattern -->
    <segment axis="y" name="len6_stub" freq="0.063158" length="6" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 1 1 0 0 1 1</sb>
            <cb type="pattern">1 1 0 0 1 1</cb>
        </segment>

    <!-- TODO: In xilinx length 12 and 18 wires are bidirectional -->

    <segment axis="x" name="len12_x" freq="0.096774" length="12" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
            <sb type="pattern">1 0 0 0 0 0 0 0 0 0 0 0 1</sb>
            <cb type="pattern">1 0 0 0 0 0 0 0 0 0 0 1</cb>
        </segment>
        <segment axis="y" name="len12_y" freq="0.063158" length="12" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 0 0 0 0 0 0 0 0 0 0 1</sb>
            <cb type="pattern">1 0 0 0 0 0 0 0 0 0 0 1</cb>
        </segment>

        <!-- No length 18 horizontal chanel's -->
    <!-- VPR throws an error if this segment in the x direction with zero frequency is not included -->
    <segment axis="x" name="len18_x" freq="0.000000" length="18" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1</sb>
            <cb type="pattern">1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1</cb>
        </segment>

        <segment axis="y" name="len18_y" freq="0.094736" length="18" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1</sb>
            <cb type="pattern">1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1</cb>
        </segment>



  <!-- TODO: Support in VPR for diagonal wires is currently in the works.
  Until full support for this feature is implemented, this part of the
  Xilinx routing is excluded. -->

  <!-- all length 4 vertical wires are part of diagonal components. We split the vertical contribution of length 4 
  wires into four separate parts so that all intercardinal directions may be specified without conflict when SB unions occur. 
  The same thing is done to length 2 wires-->
  <segment axis="y" name="1len4D_y" freq="0.084211" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0</cb>
  </segment>
  <segment axis="y" name="2len4D_y" freq="0.084211" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0</cb>
  </segment>
  <segment axis="y" name="3len4D_y" freq="0.084211" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0</cb>
  </segment>
  <segment axis="y" name="4len4D_y" freq="0.084211" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0</cb>
  </segment>

  <!-- length 2 horizontal wires that contribute to diagonal interconnect -->
  <segment axis="x" name="1len2D_x" freq="0.064516" length="2" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 1</sb>
      <cb type="pattern">0 1</cb>
    </segment>
    <segment axis="x" name="2len2D_x" freq="0.064516" length="2" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 1</sb>
      <cb type="pattern">0 1</cb>
    </segment>
    <segment axis="x" name="3len2D_x" freq="0.064516" length="2" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 1</sb>
      <cb type="pattern">1 0</cb>
    </segment>
    <segment axis="x" name="4len2D_x" freq="0.064516" length="2" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 1</sb>
      <cb type="pattern">1 0</cb>
    </segment>

    <!-- L1->L1 diagonals -->
    <segment axis="y" name="len1D_y" freq="0.023684" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
  </segment>
  <segment axis="y" name="2len1D_y" freq="0.023684" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
  </segment>
  <segment axis="y" name="3len1D_y" freq="0.023684" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
    <mux name="0"/>
    <sb type="pattern">1 1</sb>
    <cb type="pattern">1</cb>
</segment>
<segment axis="y" name="4len1D_y" freq="0.023684" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
    <mux name="0"/>
    <sb type="pattern">1 1</sb>
    <cb type="pattern">1</cb>
</segment>

  <segment axis="x" name="len1D_x" freq="0.036290" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
    <mux name="0"/>
    <sb type="pattern">1 1</sb>
    <cb type="pattern">1</cb>
</segment>
<segment axis="x" name="2len1D_x" freq="0.036290" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
    <mux name="0"/>
    <sb type="pattern">1 1</sb>
    <cb type="pattern">1</cb>
</segment>
<segment axis="x" name="3len1D_x" freq="0.036290" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
  <mux name="0"/>
  <sb type="pattern">1 1</sb>
  <cb type="pattern">1</cb>
</segment>
<segment axis="x" name="4len1D_x" freq="0.036290" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
  <mux name="0"/>
  <sb type="pattern">1 1</sb>
  <cb type="pattern">1</cb>
</segment>

<!--!!! BUG: If you misspell axsis nothing happens (no error)  -->

  </segmentlist>
  <complexblocklist>
    <!-- 1110 in  /home/chem3000/GitClones/vtr_ccl/vtr-verilog-to-routing/vtr_flow/arch/COFFE_22nm/k6FracN10LB_mem20K_complexDSP_customSB_22nm.dsp_heavy.xml 
    is an example of a DSP description -->
    <pb_type name="DSP48E1" num_pb="1">
      <clock name="CLK" num_pins="1"/>
      <input name="A" num_pins="30"/>
      <input name="ACIN" num_pins="30"/>
      <input name="ALUMODE" num_pins="4"/>
      <input name="B" num_pins="18"/>
      <input name="BCIN" num_pins="18"/>
      <input name="C" num_pins="48"/>
      <input name="CARRYCASCIN" num_pins="1"/>
      <input name="CARRYIN" num_pins="1"/>
      <input name="CARRYINSEL" num_pins="3"/>
      <input name="CEA1" num_pins="1"/>
      <input name="CEA2" num_pins="1"/>
      <input name="CEAD" num_pins="1"/>
      <input name="CEALUMODE" num_pins="1"/>
      <input name="CEB1" num_pins="1"/>
      <input name="CEB2" num_pins="1"/>
      <input name="CEC" num_pins="1"/>
      <input name="CECARRYIN" num_pins="1"/>
      <input name="CECTRL" num_pins="1"/>
      <input name="CED" num_pins="1"/>
      <input name="CEINMODE" num_pins="1"/>
      <input name="CEM" num_pins="1"/>
      <input name="CEP" num_pins="1"/>
      <input name="D" num_pins="25"/>
      <input name="INMODE" num_pins="5"/>
      <!-- <input name="MULTSIGNIN" num_pins="1"/> -->
      <input name="OPMODE" num_pins="7"/>
      <input name="PCIN" num_pins="48"/>
      <input name="RSTA" num_pins="1"/>
      <input name="RSTALLCARRYIN" num_pins="1"/>
      <input name="RSTALUMODE" num_pins="1"/>
      <input name="RSTB" num_pins="1"/>
      <input name="RSTC" num_pins="1"/>
      <input name="RSTCTRL" num_pins="1"/>
      <input name="RSTD" num_pins="1"/>
      <input name="RSTINMODE" num_pins="1"/>
      <input name="RSTM" num_pins="1"/>
      <input name="RSTP" num_pins="1"/>
      <output name="ACOUT"          num_pins="30"/>
      <output name="BCOUT"          num_pins="18"/>
      <output name="CARRYCASCOUT"   num_pins="1"/>
      <output name="CARRYOUT"       num_pins="4"/>
      <output name="MULTSIGNOUT"    num_pins="1"/>
      <output name="OVERFLOW"       num_pins="1"/>
      <output name="P"              num_pins="48"/>
      <output name="PATTERNBDETECT" num_pins="1"/>
      <output name="PATTERNDETECT"  num_pins="1"/>
      <output name="PCOUT"          num_pins="48"/>
      <output name="UNDERFLOW"      num_pins="1"/>

      <!-- Need 2 modes for D register,  -->
      <!-- need to figure out how to model a pre-adder -->

      <!-- create a rough draft first and then go out. -->
<!-- !!! rong way to do things. Instead use this eq that captures the entire slice:
!! P = (A+D)*B+C (C is cary :) 
from there you have to understand the math to do the different modes :( use Intell for that :D-->
      <!-- INMODE FF begin-->
      <pb_type name="INMODE_FF" num_pb="1" blif_model=".latch">
        <input name="INMODE" num_pins="5"/>
        <output name="dual_adder_AD" num_pins="4"/>
        <output name="dual_adder_B" num_pins="1"/>
        <clock name="clk" num_pins="1"/>
      </pb_type>
      <interconnect>
        <direct name="inmode" input="DSP48E1.INMODE" output="INMODE_FF.INMODE"/>
        <direct name="AD" input="INMODE_FF.dual_adder_AD" output="Dual_AD.sel"/>
        <direct name="B" input="INMODE_FF.dual_adder_B" output="Dual_B.sel"/>
      </interconnect>
      <!-- INMODE FF end -->

      <!-- Dual_AD begin !! fill this in with the stuff on pg. 16 latter -->
      <pb_type name="Dual_AD" num_pb="1" blif_model=".subckt ...">
        <input name="ACIN" num_pins="30"/> <!-- !!acording to xilnx this is an internal signal for DSPs and i s not driven by internal routing -->
        <input name="D" num_pins="25"/>
        <input name="A" num_pins="30"/>
        <input name="sel" num_pins="4"/>
        <output name="MULT_in" num_pins="25"/>
        <output name="WIRE_out" num_pins="30"/>
        <output name="ACOUT" num_pins="30"/> <!-- !!acording to xilnx this is an internal signal for DSPs and is not driven by internal routing -->
      </pb_type>
      <interconnect>
        <direct name="ACIN" input="DSP48E1.ACIN" output="Dual_AD.ACIN"/> <!-- !! -->
        <direct name="D" input="DSP48E1.D" output="Dual_AD.D"/>
        <direct name="A" input="DSP48E1.A" output="Dual_AD.A"/>
        <direct name="ACOUT" input="Dual_AD.ACOUT" output="DSP48E1.ACOUT"/> <!-- !! -->
        <direct name="MULT_in" input="Dual_AD.MULT_in" output="MULT.MLHAND1"/>
        <direct name="wire" input="Dual_AD.WIRE_out" output=""/> <!-- ??!! -->
      </interconnect>
      <!-- Dual_AD end -->

      <!-- Dual_B begin !! fill this in with the stuff on pg. 16 latter also throw in the correct regs for the ALU-->
      <pb_type name="Dual_B" num_pb="1" blif_model=".subckt ...">
        <input name="BCIN" num_pins="18"/> <!-- !!acording to xilnx this is an internal signal for DSPs and i s not driven by internal routing -->
        <input name="B" num_pins="1"/>
        <input name="sel" num_pins="1"/>
        <output name="MULT_in" num_pins="18"/>
        <output name="WIRE_out" num_pins="18"/>
        <output name="BCOUT" num_pins="30"/> <!-- !!acording to xilnx this is an internal signal for DSPs and is not driven by internal routing -->
      </pb_type>
      <interconnect>
        <direct name="BCIN" input="DSP48E1.BCIN" output="Dual_B.BCIN"/> <!-- !! -->
        <direct name="B" input="DSP48E1.B" output="Dual_B.B"/>

        <direct name="BCOUT" input="Dual_B.BCOUT" output="DSP48E1.BCOUT"/> <!-- !! -->
        <direct name="MULT_in" input="Dual_B.MULT_in" output="MULT.MLHAND2"/>
        <direct name="wire" input="Dual_B.WIRE_out" output=""/> <!-- ??!! -->
      </interconnect>
      <!-- Dual_B end -->

      <!-- MULT start -->
      <pb_type name="MULT" num_pb="1" blif_model=".subckt ...">
        <input name="MLHAND1" num_pins="25"/>
        <input name="MLHAND2" num_pins="18"/>
        <output name="MULT_OUT" num_pins="48"/>
      </pb_type>
      <interconnect>
      <!-- <direct name="MLHAND1" input="Dual_B.BCOUT" output="DSP48E1.BCOUT"/>
      <direct name="MLHAND2" input="Dual_B.BCOUT" output="DSP48E1.BCOUT"/> -->
      <direct name="MULT_OUT" input="MULT_OUT" output="M_in"/>
       </interconnect>
       <!-- MULT end -->
       
      <!-- M and C latch start -->
       <pb_type name="M" num_pb="1" blif_model=".latch">
        <input name="M_in" num_pins="?"/>
        <output name="M_out" num_pins="?"/>
      </pb_type>
      <interconnect>
        <direct name="M_out" input="M_out" output="X"/>
        <direct name="M_out2" input="M_out" output="Y"/>
      </interconnect>

      <pb_type name="C" num_pb="1" blif_model=".latch">
        <input name="C_in" num_pins="48"/>
        <output name="C_out" num_pins="48"/>
      </pb_type>
      <interconnect>
        <direct name="C_in" input="DSP48E1.C" output="Y"/>
        <direct name="C_out" input="C_out" output="Y"/>
        <direct name="C_out2" input="C_out" output="Z"/>
      </interconnect>
      <!-- M and C latch end -->

      <!-- use pg. 25 for a high level discription -->
      <pb_type name="ALU" num_pb="1" blif_model=".subckt multiply">
        <input name="OPMODE" num_pins="?"/>
        <input name="CARRYINSEL" num_pins="?"/>
        <input name="ALUMODE" num_pins="?"/>
        <input name="MULT_out" num_pins="?"/>
        <input name="PCIN" num_pins="?"/>
        <input name="SHIFTERS" num_pins="?"/> <!-- !! how to do this I do not know.-->
        <input name="CY" num_pins="?"/>
        <!-- we are just going to try to do the modes for the add/sub/logic for now-->
        <mode>
        <!-- Add -->
        <pb_type name="ALU" num_pb="1" blif_model=".subckt ...">
        <input name="X" num_pins="48"/>
        <input name="Y" num_pins="48"/>
        <input name="Z" num_pins="48"/>
        </pb_type>
        
        </mode>
        
        <mode>
        <!-- Sub -->
        </mode>
        
        <mode>
        <!-- Add SIMD-->
        </mode>
        
        <mode>
        <!-- Sub SIMD-->
        </mode>
        
        <mode>
        <!-- logic -->
        </mode>

        <!-- you might be able to ignore the muxes if you do the stuff right. -->

        

        <!-- Sub -->

        <!-- ALUMODE -->
        
        <!-- for now just do seperate tiles, see if it works, if not start figuring out modes. -->
        
        <!-- Notes and brainstorm: 
        1) Pg. 41 fig. 2-15 we can do (A or AD)*B
        2) pG. 42 there are 10 seperate logic modes of the adder/sub/logic this is further complicated by the fact that 
        all 10 of these logic functions can be done in SIMD (luckaly all 4 must perform the same functions :o)-->
	
      </pb_type>

    </pb_type>


    <!-- Define I/O pads begin -->
    <!-- The structure of the IO from the k6_N10_40nm arch is
    used here to approximate the seven series IO. Timing values
    are changed to match the seven series.-->
    <pb_type name="io">
      <input name="outpad" num_pins="1"/>
      <output name="inpad" num_pins="1"/>
      <clock name="clock" num_pins="1"/>
      <!-- IOs can operate as either inputs or outputs.
           Delays below are pulled from the IOBUF description
       in f4pga/symbiflow's arch.timing.xml
           -->
      <mode name="inpad">
        <pb_type name="inpad" blif_model=".input" num_pb="1">
          <output name="inpad" num_pins="1"/>
        </pb_type>
        <interconnect>
          <direct name="inpad" input="inpad.inpad" output="io.inpad">
          <!-- delay bellow is pulled from f4pga/symbiflow's arch.timing architecture -->
            <delay_constant max="10e-12" in_port="inpad.inpad" out_port="io.inpad"/>
          </direct>
        </interconnect>
      </mode>
      <mode name="outpad">
        <pb_type name="outpad" blif_model=".output" num_pb="1">
          <input name="outpad" num_pins="1"/>
        </pb_type>
        <interconnect>
          <direct name="outpad" input="io.outpad" output="outpad.outpad">
          <!-- delay bellow is pulled from f4pga/symbiflow's arch.timing architecture -->
            <delay_constant max="10e-12" in_port="io.outpad" out_port="outpad.outpad"/>
          </direct>
        </interconnect>
      </mode>
      <!-- Every input pin is driven by 15% of the tracks in a channel, every output pin is driven by 10% of the tracks in a channel -->
      <!-- IOs go on the periphery of the FPGA, for consistency,
            make it physically equivalent on all sides so that only one definition of I/Os is needed.
          -->
      <!-- Place I/Os on the sides of the FPGA -->
      <power method="ignore"/>
    </pb_type>
    <!-- Define I/O pads ends -->

    <pb_type name="clb">
      <clock name="CLK" num_pins="1"/>
      <input name="I" num_pins="56"/>
      <output name="O" num_pins="24"/>
      <pb_type name="slice" num_pb="2">
        <clock name="CLK" num_pins="1"/>
        <input name="I" num_pins="28" />
        <output name="O" num_pins="12"/>
        <pb_type name="fle" num_pb="4">
          <input name="in" num_pins="6"/>
          <input name="inX" num_pins="1"/>
          <output name="out" num_pins="1"/>
          <output name="outMUX" num_pins="1"/>
          <output name="outQ" num_pins="1"/>
          <clock name="clk" num_pins="1"/>
          <pb_type name="ALUT" num_pb="1">
            <input name="A" num_pins="6"/>
            <output name="O5" num_pins="1"/>
            <output name="O6" num_pins="1"/>
            <mode name="n2_lut5">
              <pb_type name="lut5_mode" num_pb="1">
                <input name="in" num_pins="5"/>
                <output name="out" num_pins="1"/>
                <pb_type name="lut5" blif_model=".names" num_pb="1" class="lut">
                  <input name="in" num_pins="5" port_class="lut_in"/>
                  <output name="out" num_pins="1" port_class="lut_out"/>
                  <!-- LUT timing using delay matrix -->
                  <!-- These are the physical delay inputs on a seven series LUT. These values are pulled from f4pga/symbiflow's arch file-->
                  <delay_matrix in_port="lut5.in" out_port="lut5.out" type="max">
                  1.5200000000000002e-10
                  1.5200000000000002e-10
                  1.5e-10
                  1.5e-10
                  1.18e-10
                  </delay_matrix>
                  <delay_matrix in_port="lut5.in" out_port="lut5.out" type="min">
                  4.4e-11
                  4.4e-11
                  4.2000000000000004e-11
                  4.6e-11
                  4.8e-11
                  </delay_matrix>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="lut5_mode.in" output="lut5.in"/>
                  <direct name="direct2" input="lut5.out" output="lut5_mode.out"/>
                </interconnect>
              </pb_type>
              <interconnect>
                <direct name="direct1" input="ALUT.A[4:0]" output="lut5_mode.in"/>
                <direct name="direct3" input="lut5_mode.out" output="ALUT.O5"/>
              </interconnect>
            </mode>
            <mode name="n1_lut6">
              <pb_type name="lut6_mode" num_pb="1">
                <input name="in" num_pins="6"/>
                <output name="out" num_pins="1"/>
                <pb_type name="lut6" blif_model=".names" num_pb="1" class="lut">
                  <input name="in" num_pins="6" port_class="lut_in"/>
                  <output name="out" num_pins="1" port_class="lut_out"/>
                  <!-- LUT timing using delay matrix -->
                  <!-- These are the physical delay inputs on a seven series LUT. These values are pulled from f4pga/symbiflow's arch file-->
                  <delay_matrix in_port="lut6.in" out_port="lut6.out" type="max">
                  1.6200000000000002e-10
                  1.6200000000000002e-10
                  1.6e-10
                  1.6e-10
                  1.6e-10
                  1.28e-10
                  </delay_matrix>
                  <delay_matrix in_port="lut6.in" out_port="lut6.out" type="min">
                  4.4e-11
                  4.4e-11
                  4.2000000000000004e-11
                  4.6e-11
                  4.5e-11
                  4.8e-11
                  </delay_matrix>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="lut6_mode.in" output="lut6.in"/>
                  <direct name="direct2" input="lut6.out" output="lut6_mode.out"/>
                </interconnect>
              </pb_type>
              <interconnect>
                <direct name="direct1" input="ALUT.A" output="lut6_mode.in"/>
                <direct name="direct2" input="lut6_mode.out" output="ALUT.O6"/>
              </interconnect>
            </mode>
          </pb_type>

          <pb_type blif_model=".latch" name="FDSE" num_pb="2" class="flipflop">
            <clock name="clk" num_pins="1" port_class="clock"/>
            <input name="D" num_pins="1" port_class="D"/>
            <output name="Q" num_pins="1" port_class="Q"/>
            <T_setup clock="clk" port="FDSE.D" value="-4.6e-11"/>
            <T_hold clock="clk" port="FDSE.D" value="1.81e-10"/>
            <T_clock_to_Q clock="clk" max="3.03e-10" port="FDSE.Q" min="9.900000000000001e-11"/>
          </pb_type>
          <!-- The following interconnect matches that of the seven series.
          Delays are pulled from the f4pga/symbiflow arch -->
          <interconnect>
            <mux name="AOUTMUX" input="ALUT.O5 ALUT.O6 FDSE[0].Q" output="fle.outMUX">
              <delay_constant in_port="FDSE[0].Q" max="1.73e-10" out_port="fle.outMUX"/>
              <delay_constant in_port="ALUT[0].O6" max="2.05e-10" out_port="fle.outMUX"/>
              <delay_constant in_port="ALUT[0].O5" max="2.0300000000000002e-10" out_port="fle.outMUX"/>
            </mux>
            <mux name="FFMUX" input="ALUT.O5 fle.inX" output="FDSE[0].D">
              <delay_constant in_port="fle.inX" max="2.0200000000000003e-10" out_port="FDSE[0].D"/>
                        <delay_constant in_port="ALUT.O5" max="1.07e-10" out_port="FDSE[0].D"/>
            </mux>
            <mux name="A5FFMUX" input="ALUT.O5 ALUT.O6 fle.inX" output="FDSE[1].D">
              <delay_constant in_port="fle.inX" max="2.14e-10" out_port="FDSE[1].D"/>
              <delay_constant in_port="ALUT.O5" max="9.6e-11" out_port="FDSE[1].D"/>
              <delay_constant in_port="ALUT.O6" max="1.07e-10" out_port="FDSE[1].D"/>
            </mux>
            <direct name="inputs" input="fle.in" output="ALUT.A"/>
            <direct name="outA" input="ALUT.O6" output="fle.out"/>
            <direct name="outQ" input="FDSE[1].Q" output="fle.outQ"/>
            <complete name="clocks" input="fle.clk" output="FDSE[1:0].clk"/>
          </interconnect>
        </pb_type>

        <interconnect>
          <complete input="slice.CLK" name="CK" output="fle.clk"/>
          <direct name="dir1" input="fle[0].outMUX" output="slice.O[0]"/>
          <direct name="dir2" input="fle[0].out" output="slice.O[1]"/>
          <direct name="dir3" input="fle[0].outQ" output="slice.O[2]"/>
          <direct name="dir4" input="fle[1].outMUX" output="slice.O[3]"/>
          <direct name="dir5" input="fle[1].out" output="slice.O[4]"/>
          <direct name="dir6" input="fle[1].outQ" output="slice.O[5]"/>
          <direct name="dir7" input="fle[2].outMUX" output="slice.O[6]"/>
          <direct name="dir8" input="fle[2].out" output="slice.O[7]"/>
          <direct name="dir9" input="fle[2].outQ" output="slice.O[8]"/>
          <direct name="dir10" input="fle[3].outMUX" output="slice.O[9]"/>
          <direct name="dir11" input="fle[3].out" output="slice.O[10]"/>
          <direct name="dir12" input="fle[3].outQ" output="slice.O[11]"/>
          <direct name="inA" input="slice.I[5:0]" output="fle[0].in"/>
          <direct name="inB" input="slice.I[12:7]" output="fle[1].in"/>
          <direct name="inC" input="slice.I[19:14]" output="fle[2].in"/>
          <direct name="inD" input="slice.I[26:21]" output="fle[3].in"/>
        </interconnect>
      </pb_type>
      <!-- Partial Crossbar with each input to the slice connected to 3 outputs from the same slice.
      Values are taken from prjxray-db/artix7/tile_int_l -->
      <interconnect>
        <direct name="top_slice" input="clb.I[27:0]" output="slice[0].I"/>
        <direct name="bottom_slice" input="clb.I[55:28]" output="slice[1].I"/>
        <direct name="top_slice_O" input="slice[0].O" output="clb.O[0:11]"/>
        <direct name="bottom_slice_O" input="slice[1].O" output="clb.O[12:23]"/>
        <complete name="CLK" input="clb.CLK" output="slice.CLK"/>
        <complete name="cross0" input="slice[0].O[6] slice[0].O[1] slice[1].O[2]" output="slice[1].I[2]"/>
        <complete name="cross1" input="slice[1].O[6] slice[1].O[1] slice[0].O[2]" output="slice[0].I[2]"/>
        <complete name="cross2" input="slice[1].O[9] slice[1].O[4] slice[0].O[5]" output="slice[0].I[1]"/>
        <complete name="cross3" input="slice[0].O[9] slice[0].O[4] slice[1].O[5]" output="slice[1].I[1]"/>
        <complete name="cross4" input="slice[0].O[0] slice[0].O[7] slice[1].O[8]" output="slice[0].I[5]"/>
        <complete name="cross5" input="slice[1].O[0] slice[1].O[7] slice[0].O[8]" output="slice[1].I[5]"/>
        <complete name="cross6" input="slice[1].O[3] slice[1].O[10] slice[0].O[11]" output="slice[1].I[0]"/>
        <complete name="cross7" input="slice[0].O[3] slice[0].O[10] slice[1].O[11]" output="slice[0].I[1]"/>
        <complete name="cross8" input="slice[0].O[6] slice[1].O[2] slice[0].O[1]" output="slice[0].I[4]"/>
        <complete name="cross9" input="slice[1].O[6] slice[0].O[2] slice[1].O[1]" output="slice[1].I[4]"/>
        <complete name="cross10" input="slice[1].O[9] slice[0].O[5] slice[1].O[4]" output="slice[1].I[3]"/>
        <complete name="cross11" input="slice[0].O[9] slice[1].O[5] slice[0].O[4]" output="slice[0].I[3]"/>
        <complete name="cross12" input="slice[0].O[0] slice[1].O[8] slice[0].O[7]" output="slice[0].I[12]"/>
        <complete name="cross13" input="slice[1].O[0] slice[0].O[8] slice[1].O[7]" output="slice[0].I[12]"/>
        <complete name="cross14" input="slice[1].O[3] slice[0].O[11] slice[1].O[10]" output="slice[1].I[7]"/>
        <complete name="cross15" input="slice[0].O[3] slice[1].O[11] slice[0].O[10]" output="slice[0].I[7]"/>
        <complete name="cross16" input="slice[0].O[6] slice[0].O[1] slice[1].O[2]" output="slice[1].I[9]"/>
        <complete name="cross17" input="slice[1].O[6] slice[1].O[1] slice[0].O[2]" output="slice[0].I[9]"/>
        <complete name="cross18" input="slice[1].O[9] slice[1].O[4] slice[0].O[5]" output="slice[0].I[8]"/>
        <complete name="cross19" input="slice[0].O[9] slice[0].O[4] slice[1].O[5]" output="slice[1].I[8]"/>
        <complete name="cross20" input="slice[0].O[0] slice[0].O[7] slice[1].O[8]" output="slice[1].I[15]"/>
        <complete name="cross21" input="slice[1].O[0] slice[1].O[7] slice[0].O[8]" output="slice[1].I[17]"/>
        <complete name="cross22" input="slice[1].O[3] slice[1].O[10] slice[0].O[11]" output="slice[0].I[16]"/>
        <complete name="cross23" input="slice[0].O[3] slice[0].O[10] slice[1].O[11]" output="slice[1].I[16]"/>
        <complete name="cross24" input="slice[0].O[6] slice[1].O[2] slice[0].O[1]" output="slice[0].I[11]"/>
        <complete name="cross25" input="slice[1].O[6] slice[0].O[2] slice[1].O[1]" output="slice[1].I[11]"/>
        <complete name="cross26" input="slice[1].O[9] slice[0].O[5] slice[1].O[4]" output="slice[1].I[10]"/>
        <complete name="cross27" input="slice[0].O[9] slice[1].O[5] slice[0].O[4]" output="slice[0].I[10]"/>
        <complete name="cross28" input="slice[0].O[0] slice[1].O[8] slice[0].O[7]" output="slice[0].I[17]"/>
        <complete name="cross29" input="slice[1].O[0] slice[0].O[8] slice[1].O[7]" output="slice[0].I[15]"/>
        <complete name="cross30" input="slice[1].O[3] slice[0].O[11] slice[1].O[10]" output="slice[1].I[18]"/>
        <complete name="cross31" input="slice[0].O[3] slice[1].O[11] slice[0].O[10]" output="slice[0].I[18]"/>
        <complete name="cross32" input="slice[0].O[6] slice[0].O[1] slice[1].O[2]" output="slice[0].I[14]"/>
        <complete name="cross33" input="slice[1].O[6] slice[1].O[1] slice[0].O[2]" output="slice[1].I[14]"/>
        <complete name="cross34" input="slice[1].O[9] slice[1].O[4] slice[0].O[5]" output="slice[1].I[19]"/>
        <complete name="cross35" input="slice[0].O[9] slice[0].O[4] slice[1].O[5]" output="slice[0].I[19]"/>
        <complete name="cross36" input="slice[0].O[0] slice[0].O[7] slice[1].O[8]" output="slice[1].I[22]"/>
        <complete name="cross37" input="slice[1].O[0] slice[1].O[7] slice[0].O[8]" output="slice[1].I[24]"/>
        <complete name="cross38" input="slice[1].O[3] slice[1].O[10] slice[0].O[11]" output="slice[0].I[23]"/>
        <complete name="cross39" input="slice[0].O[3] slice[0].O[10] slice[1].O[11]" output="slice[1].I[23]"/>
        <complete name="cross40" input="slice[0].O[6] slice[1].O[2] slice[0].O[1]" output="slice[0].I[21]"/>
        <complete name="cross41" input="slice[1].O[6] slice[0].O[2] slice[1].O[1]" output="slice[1].I[21]"/>
        <complete name="cross42" input="slice[1].O[9] slice[0].O[5] slice[1].O[4]" output="slice[1].I[26]"/>
        <complete name="cross43" input="slice[0].O[9] slice[1].O[5] slice[0].O[4]" output="slice[0].I[26]"/>
        <complete name="cross44" input="slice[0].O[0] slice[1].O[8] slice[0].O[7]" output="slice[0].I[24]"/>
        <complete name="cross45" input="slice[1].O[0] slice[0].O[8] slice[1].O[7]" output="slice[0].I[22]"/>
        <complete name="cross46" input="slice[1].O[3] slice[0].O[11] slice[1].O[10]" output="slice[1].I[25]"/>
        <complete name="cross47" input="slice[0].O[3] slice[1].O[11] slice[0].O[10]" output="slice[0].I[25]"/>
      </interconnect>
    </pb_type>
    <!-- Define general purpose logic block (CLB) ends -->
  </complexblocklist>
  <!-- TODO: Custom SB's and independent wire distributions in the x/y direction are not fully supported yet. 
    After this full support becomes available, a better capture of the xilinx wire interconnect can be achieved.   -->
   
    
    <switchblocklist>
      <!-- custom SBs used to create diagonal wires -->
      <switchblock name="diagonal_cw_turns" type="unidir">
          <switchblock_location type="EVERYWHERE"/>
          <switchfuncs>
            <!-- Clock-wise turns -->
            <func type="tl" formula="W-t"/>
            <!-- top to left -->
            <func type="rt" formula="t+1"/>
            <!-- right to top -->
            <func type="br" formula="2*W-2-t"/>
            <!-- bottom to right -->
            <func type="lb" formula="t+1"/>
            <!-- left to bottom -->
          </switchfuncs>
          <wireconn num_conns="min(from,to)" from_type="1len4D_y" from_switchpoint="0" to_type="1len2D_x" to_switchpoint="0" switch_override="electrical_short2"/>  <!-- technichly we could do diagonal wires by just creating a switch override in side wireconn -->
          <wireconn num_conns="min(from,to)" from_type="3len2D_x" from_switchpoint="0" to_type="3len4D_y" to_switchpoint="0" switch_override="electrical_short2"/>
          <wireconn num_conns="min(from,to)" from_type="len1D_y" from_switchpoint="0" to_type="len1D_x" to_switchpoint="0" switch_override="electrical_short2"/>
          <wireconn num_conns="min(from,to)" from_type="3len1D_x" from_switchpoint="0" to_type="3len1D_y" to_switchpoint="0" switch_override="electrical_short2"/>
      </switchblock>

      <switchblock name="diagonal_ccw_turns" type="unidir">
          <switchblock_location type="EVERYWHERE"/>
          <switchfuncs>
              <func type="lt" formula="W-t"/>
              <func type="tr" formula="t+1"/>
              <func type="rb" formula="2*W-2-t"/>
              <func type="bl" formula="t+1"/>
          </switchfuncs>
          <wireconn num_conns="min(from,to)" from_type="2len4D_y" from_switchpoint="0" to_type="2len2D_x" to_switchpoint="0" switch_override="electrical_short2"/>
          <wireconn num_conns="min(from,to)" from_type="4len2D_x" from_switchpoint="0" to_type="4len4D_y" to_switchpoint="0" switch_override="electrical_short2"/>
          <wireconn num_conns="min(from,to)" from_type="2len1D_y" from_switchpoint="0" to_type="2len1D_x" to_switchpoint="0" switch_override="electrical_short2"/>
          <wireconn num_conns="min(from,to)" from_type="4len1D_x" from_switchpoint="0" to_type="4len1D_y" to_switchpoint="0" switch_override="electrical_short2"/>
      </switchblock>
      <!-- End custom SBs used to create diagonal wires --> 

      <!-- Normal interconnect (following wilton typology for now) -->
      <!-- <switchblock name="normal_x" type="unidir">
        <switchblock_location type="EVERYWHERE"/>
        <switchfuncs>

            <func type="rt" formula="W-t"/>

            <func type="rb" formula="t+1"/>

            <func type="lt" formula="2*W-2-t"/>
 
            <func type="lb" formula="t+1"/>
  
            <func type="lr" formula="t"/>
          
            <func type="rl" formula="t"/>
        
        </switchfuncs>
       !! what replaces dummy wire x: len1_x,len2_x,len4_x,len4_stub,len12_x 
         !! what replaces dummy wire y: len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y
        <wireconn num_conns="min(from,to)" from_type="1len2D_x,2len2D_x,len1_x,len2_x,len4_x,len4_stub,len12_x,stub" from_switchpoint="0" to_type="len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,2len4D_y" to_switchpoint="0"/>
        <wireconn num_conns="min(from,to)" from_type="len4_x,len4_stub" from_switchpoint="0" to_type="len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,2len4D_y" to_switchpoint="0"/>

        <wireconn num_conns="min(from,to)" from_type="len4_stub" from_switchpoint="1,2" to_type="len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,2len4D_y" to_switchpoint="0"/>
      </switchblock> -->




      <switchblock name="NE_SE_x" type="unidir">
        <switchblock_location type="EVERYWHERE"/>
        <switchfuncs>
           <!-- Clock-wise turns -->
            <func type="lt" formula="W-t"/> <!-- !!! need to change these EQs to match. -->
            <!-- top to left -->
            <func type="lb" formula="t+1"/>
            <!-- right to top -->
            <func type="lr" formula="2*W-2-t"/>
            <!-- bottom to right -->
          
        </switchfuncs>
       <!--  when you make multiple from sets you split all the connections in the to set up. Number of connections is NUMBER OF CONNECTIONS -->
       <!-- nw se are 2L4 and 3L2 -->
        <!-- <wireconn num_conns="min(from,to)" from_type="len4_x" from_switchpoint="0" to_type="len1_x,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len6_stub,len12_y,len18_y,len1D_y" to_switchpoint="0"/> 
        <wireconn num_conns="min(from,to)" from_type="len4_stub" from_switchpoint="0,1,2" to_type="len1_x,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len6_stub,len12_y,len18_y,len1D_y" to_switchpoint="0"/>  -->
        
        <!-- NE 2,6 from L -->         <!-- technichly WW2, SS2, SS6 is not alowed but we leave it here, N1 also has 8 cons but we leave it becaus it is the one and only outlier. we alwo cant do one type of NE turn in the same direction (I think that is ok though)-->
        <wireconn num_conns="to" from_type="len1D_x,1len2D_x" from_switchpoint="0" to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,2len1D_y,3len1D_x" to_switchpoint="0"/>
        <wireconn num_conns="to" from_type="1len2D_x" from_switchpoint="0" to_type="len12_x" to_switchpoint="0"/>

        <!-- SE 2,6 from L -->
        <wireconn num_conns="to" from_type="2len1D_x,2len2D_x" from_switchpoint="0" to_type="len1_x,len1_y,len6_y,len6_stub,len2_y,len2_x,len4_x,len4_stub,3len2D_x,2len1D_y,1len4D_y,1len2D_x,len1D_y,len1D_x" to_switchpoint="0"/>
        <wireconn num_conns="to" from_type="2len2D_x" from_switchpoint="0" to_type="len12_y" to_switchpoint="0"/>

        <!-- EE4 and EE2 -->
        <wireconn num_conns="to" from_type="len4_x,len2_x" from_switchpoint="0" to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,1len4D_y,2len4D_y,3len2D_x,2len1D_y,3len1D_x,4len2D_x,1len4D_y" to_switchpoint="0"/>
        <wireconn num_conns="to" from_type="len4_stub" from_switchpoint="0,1,2" to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,1len4D_y,2len4D_y,3len2D_x,2len1D_y,3len1D_x,4len2D_x,1len4D_y,len12_x" to_switchpoint="0"/>
        <wireconn num_conns="to" from_type="len4_x" from_switchpoint="0" to_type="len12_x" to_switchpoint="0"/>

        <!-- EL1 -->
        <wireconn num_conns="7*from" from_type="len1_x" from_switchpoint="0" to_type="len1_y,len2_x,len2_y,len1D_y,4len1D_x,2len1D_y,3len1D_x,len18_y,len12_x" to_switchpoint="0"/>
        <wireconn num_conns="2*from" from_type="len1_x" from_switchpoint="0" to_type="len1_x" to_switchpoint="0"/>

         <!-- L12 -->
        <wireconn num_conns="14" from_type="len12_x" from_switchpoint="0" to_type="len12_x,len12_y,len18_y,len6_y,len6_stub,4len2D_x,1len4D_y,3len2D_x,2len4D_y,len4_x,len4_stub" to_switchpoint="0"/>
        
      </switchblock>

      <switchblock name="NE_NW_y" type="unidir">
        <switchblock_location type="EVERYWHERE"/>
        <switchfuncs>
           <!-- Clock-wise turns -->
            <func type="bt" formula="W-t"/> <!-- !!! need to change these EQs to match. -->
            <!-- top to left -->
            <func type="bl" formula="t+1"/>
            <!-- right to top -->
            <func type="br" formula="2*W-2-t"/>
            <!-- bottom to right -->
          
        </switchfuncs>
       <!--  when you make multiple from sets you split all the connections in the to set up. Number of connections is NUMBER OF CONNECTIONS -->

        
        <!-- NE 2,6 from L -->         <!-- technichly WW2, SS2, SS6 is not alowed but we leave it here, N1 also has 8 cons but we leave it becaus it is the one and only outlier. we alwo cant do one type of NE turn in the same direction (I think that is ok though)-->
        <wireconn num_conns="to" from_type="len1D_y,1len4D_y" from_switchpoint="0" to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,2len1D_y,3len1D_x" to_switchpoint="0"/>
        <wireconn num_conns="to" from_type="1len4D_y" from_switchpoint="0" to_type="len12_x" to_switchpoint="0"/>
        <wireconn num_conns="to" from_type="len1D_y" from_switchpoint="0" to_type="len12_x,len12_y" to_switchpoint="0"/>

        <!-- NW 2,6 the fact this is bottom to garenties this is NW and not SE-->
        <wireconn num_conns="to" from_type="3len1D_y,3len4D_y" from_switchpoint="0" to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,2len1D_y,3len1D_x" to_switchpoint="0"/>

        <!-- NN2 and 6 connection -->
        <wireconn num_conns="to" from_type="len2_y,len6_y" from_switchpoint="0" to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,2len4D_y,4len1D_x,4len2D_x,2len1D_y,3len1D_x,3len2D_x" to_switchpoint="0"/>
        <wireconn num_conns="to" from_type="len6_y" from_switchpoint="0" to_type="len18_y,len12_y" to_switchpoint="0"/>

        <!-- NL1 -->
        <wireconn num_conns="7*from" from_type="len1_y" from_switchpoint="0" to_type="len1_x,len2_x,len2_y,len1D_y,4len1D_x,2len1D_y,3len1D_x,,len18_y,len12_y" to_switchpoint="0"/>
        <wireconn num_conns="2*from" from_type="len1_y" from_switchpoint="0" to_type="len1_y" to_switchpoint="0"/>

        <!-- L18 L12 -->
        <wireconn num_conns="13" from_type="len18_y" from_switchpoint="0" to_type="len12_x,len12_y,len18_y,len6_y,len6_stub,4len2D_x,1len4D_y,3len2D_x,2len4D_y,len4_x,len4_stub" to_switchpoint="0"/>

        <wireconn num_conns="10" from_type="len12_y" from_switchpoint="0" to_type="len12_y,len6_y,len6_stub,4len2D_x,1len4D_y,3len2D_x,2len4D_y,len4_x,len4_stub" to_switchpoint="0"/>

      </switchblock>

      <switchblock name="SW_SE_x" type="unidir">
        <switchblock_location type="EVERYWHERE"/>
        <switchfuncs>
           <!-- Clock-wise turns -->
            <func type="tb" formula="W-t"/> <!-- !!! need to change these EQs to match. -->
            <!-- top to left -->
            <func type="tl" formula="t+1"/>
            <!-- right to top -->
            <func type="tr" formula="2*W-2-t"/>
            <!-- bottom to right -->
          
        </switchfuncs>
       <!--  when you make multiple from sets you split all the connections in the to set up. Number of connections is NUMBER OF CONNECTIONS -->
       <!-- nw se are 2L4 and 3L2 -->
        <!-- <wireconn num_conns="min(from,to)" from_type="len4_x" from_switchpoint="0" to_type="len1_x,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len6_stub,len12_y,len18_y,len1D_y" to_switchpoint="0"/> 
        <wireconn num_conns="min(from,to)" from_type="len4_stub" from_switchpoint="0,1,2" to_type="len1_x,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len6_stub,len12_y,len18_y,len1D_y" to_switchpoint="0"/>  -->
        
        <!-- SW 2,6 from T -->         <!-- technichly WW2, SS2, SS6 is not alowed but we leave it here, N1 also has 8 cons but we leave it becaus it is the one and only outlier. we alwo cant do one type of NE turn in the same direction (I think that is ok though)-->
        <wireconn num_conns="to" from_type="4len1D_y,4len4D_y" from_switchpoint="0" to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,2len1D_y,3len1D_x" to_switchpoint="0"/>

        <!-- SE 2,6 from T -->
        <wireconn num_conns="to" from_type="3len1D_y,3len4D_y" from_switchpoint="0" to_type="len1_x,len1_y,len6_y,len6_stub,len2_y,len2_x,len4_x,len4_stub,3len2D_x,2len1D_y,1len4D_y,4len2D_x,len1D_y,4len1D_x" to_switchpoint="0"/>
        <wireconn num_conns="to" from_type="3len4D_y,3len1D_y" from_switchpoint="0" to_type="len12_y" to_switchpoint="0"/> 
      

        <!-- South bound connections (from top only) -->
        <!-- SS2, SS6 -->
        <wireconn num_conns="to" from_type="len2_y,len6_y" from_switchpoint="0" to_type="len1_x,len1_y,len6_y,len6_stub,len2_y,len2_x,len4_x,len4_stub,3len2D_x,2len4D_y,2len1D_y,3len1D_x,1len4D_y,4len2D_x,len1D_y,4len1D_x,len12_x" to_switchpoint="0"/> <!-- len12 should only conn from ss6 not 2-->
        <!-- I think 28from is the best option -->
        <wireconn num_conns="2*from" from_type="len6_stub" from_switchpoint="0,1,2,5" to_type="len1_x,len1_y,len6_y,len6_stub,len2_y,len2_x,len4_x,len4_stub,3len2D_x,2len4D_y,2len1D_y,3len1D_x,1len4D_y,4len2D_x,len1D_y,4len1D_x,len12_x" to_switchpoint="0"/> 
        <!-- ^^ stright conns are ok in the middle because in xilinx these cons would happen anyway. -->

        <!-- S1 note that this is the most iregular  -->
        <wireconn num_conns="7*from" from_type="len1_y" from_switchpoint="0" to_type="len1_x,len2_x,len2_y,len1D_y,4len1D_x,2len1D_y,3len1D_x,len18_y,len12_x" to_switchpoint="0"/>
        <wireconn num_conns="2*from" from_type="len1_y" from_switchpoint="0" to_type="len1_y" to_switchpoint="0"/>

        <!-- L18 and L12 -->
        <wireconn num_conns="10" from_type="len18_y" from_switchpoint="9" to_type="len12_x,len6_y,len6_stub,4len2D_x,1len4D_y,3len2D_x,2len4D_y,len4_x,len4_stub" to_switchpoint="0"/>
        <wireconn num_conns="13" from_type="len18_y" from_switchpoint="0" to_type="len12_x,len12_y,len18_y,len6_y,len6_stub,4len2D_x,1len4D_y,3len2D_x,2len4D_y,len4_x,len4_stub" to_switchpoint="0"/>

        <wireconn num_conns="10" from_type="len12_y" from_switchpoint="0" to_type="len12_y,len6_y,len6_stub,4len2D_x,1len4D_y,3len2D_x,2len4D_y,len4_x,len4_stub" to_switchpoint="0"/>

      </switchblock>

      <switchblock name="SW_NW_x" type="unidir">
        <switchblock_location type="EVERYWHERE"/>
        <switchfuncs>
           <!-- Clock-wise turns -->
            <func type="rl" formula="W-t"/> <!-- !!! need to change these EQs to match. -->
            <!-- top to left -->
            <func type="rt" formula="t+1"/>
            <!-- right to top -->
            <func type="rb" formula="2*W-2-t"/>
            <!-- bottom to right -->
          
        </switchfuncs>
       <!--  when you make multiple from sets you split all the connections in the to set up. Number of connections is NUMBER OF CONNECTIONS -->
       <!-- nw se are 2L4 and 3L2 -->
        <!-- <wireconn num_conns="min(from,to)" from_type="len4_x" from_switchpoint="0" to_type="len1_x,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,len1D_y" to_switchpoint="0"/> 
        <wireconn num_conns="min(from,to)" from_type="len4_stub" from_switchpoint="0,1,2" to_type="len1_x,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,len1D_y" to_switchpoint="0"/>  -->
        
        <!-- SW 2,6 from T -->         <!-- technichly WW2, SS2, SS6 is not alowed but we leave it here, N1 also has 8 cons but we leave it becaus it is the one and only outlier. we alwo cant do one type of NE turn in the same direction (I think that is ok though)-->
        <wireconn num_conns="to" from_type="4len1D_x,4len2D_x" from_switchpoint="0" to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,2len1D_y,3len1D_x" to_switchpoint="0"/>
        <wireconn num_conns="to" from_type="4len2D_x" from_switchpoint="0" to_type="len18_y,len12_y" to_switchpoint="0"/> 
        <wireconn num_conns="from" from_type="4len1D_x" from_switchpoint="0" to_type="len12_y" to_switchpoint="0"/> 

        <!-- NW 2,6 the fact this is bottom to garenties this is NW and not SE-->
        <wireconn num_conns="to" from_type="3len1D_x,3len2D_x" from_switchpoint="0" to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,2len1D_y,3len1D_x" to_switchpoint="0"/>
        <wireconn num_conns="to" from_type="3len2D_x" from_switchpoint="0" to_type="len18_y,len12_y" to_switchpoint="0"/> 
        <wireconn num_conns="to" from_type="3len1D_x" from_switchpoint="0" to_type="len12_x,len12_y" to_switchpoint="0"/> 

        <!-- WW4 WW2 interconn -->
        <wireconn num_conns="to" from_type="len4_x,len2_x" from_switchpoint="0" to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,1len4D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,len18_y,len12_y" to_switchpoint="0"/> <!-- watch out technichly len18 and 12 should only be connected to ww4 not 2-->
        <wireconn num_conns="min(from,to)" from_type="len4_stub" from_switchpoint="0,1,2" to_type="len1_x,len1_y,len2_x,len4_x,len4_stub,len2_y,len6_y,len6_stub,len1D_y,1len4D_y,4len1D_x,4len2D_x,2len4D_y,3len2D_x,len18_y,len12_y" to_switchpoint="0"/>

        <!-- WL1 -->
        <wireconn num_conns="7*from" from_type="len1_x" from_switchpoint="0" to_type="len1_y,len2_x,len2_y,len1D_y,4len1D_x,2len1D_y,3len1D_x,len18_y,len12_y" to_switchpoint="0"/>
        <wireconn num_conns="2*from" from_type="len1_x" from_switchpoint="0" to_type="len1_x" to_switchpoint="0"/>

        <!-- L12 -->
        <wireconn num_conns="14" from_type="len12_x" from_switchpoint="0" to_type="len12_x,len12_y,len18_y,len6_y,len6_stub,4len2D_x,1len4D_y,3len2D_x,2len4D_y,len4_x,len4_stub" to_switchpoint="0"/>

      </switchblock>

    <switchblock name="stubs" type="unidir">
      <switchblock_location type="EVERYWHERE"/>
      <switchfuncs>
        <!-- for diagonal 2L2 and L2 and L2 norm and L4 norm  -->
          <func type="rb" formula="W-t"/>
          <func type="lt" formula="W-t"/>
          <!-- for L1 -->
          <!-- <func type="lb" formula="W-t"/> -->
      </switchfuncs>
      <wireconn num_conns="min(to,from)" from_type="1len2D_x,2len2D_x,len2_x,len4_x" from_switchpoint="0" to_type="stub" to_switchpoint="0" switch_override="electrical_short2"/>
    </switchblock>

    <switchblock name="stubs_L1" type="unidir">
      <switchblock_location type="EVERYWHERE"/>
      <switchfuncs>
          <!-- for L1 -->
          <func type="lb" formula="W-t"/>
      </switchfuncs>
      <wireconn num_conns="min(to,from)" from_type="len1_x" from_switchpoint="0" to_type="stub" to_switchpoint="0" switch_override="electrical_short2"/>
    </switchblock>

    <switchblock name="from_stubs" type="unidir">
      <switchblock_location type="EVERYWHERE"/>
      <switchfuncs>
        <func type="tr" formula="W-t"/>
        
        <func type="tl" formula="t+1"/>
     
        <func type="br" formula="2*W-2-t"/>
    
        <func type="bl" formula="t+1"/>

        <func type="tb" formula="t"/>
       
        <func type="bt" formula="t"/>
      </switchfuncs>
      <wireconn num_conns="3*from" from_type="stub" from_switchpoint="0" to_type="len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,3len2D_x,4len2D_x,len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x" to_switchpoint="0"/>
    </switchblock>

    <!-- In order to do a proper interconn and not have diagonals gain improper interconn, specify corner bot, left by only alowing for tr and lt cons
    for left fringe do rt,rb,tr,br only  -->

    <switchblock name="fringe" type="unidir">
      <switchblock_location type="PERIMETER"/>
      <switchfuncs>
                  <!-- Counter-clock-wise turns -->
        <func type="lt" formula="W-t"/>
        <!-- left to top -->
        <func type="tr" formula="t+1"/>
        <!-- top to right -->
        <func type="rb" formula="2*W-2-t"/>
        <!-- right to bottom -->
        <func type="bl" formula="t+1"/>
        <!-- bottom to left -->
        <!-- Clock-wise turns -->
        <func type="tl" formula="W-t"/>
        <!-- top to left -->
        <func type="rt" formula="t+1"/>
        <!-- right to top -->
        <func type="br" formula="2*W-2-t"/>
        <!-- bottom to right -->
        <func type="lb" formula="t+1"/>
        <!-- left to bottom -->
      </switchfuncs>
      <!-- <wireconn num_conns="max(from,to)" from_type="len1_y,len1D_y,2len1D_y,3len1D_y,4len1D_y,len2_y,len6_y,len6_stub,len12_y,len18_y,1len4D_y,2len4D_y,3len4D_y,4len4D_y,1len2D_x,2len2D_x,3len2D_x,4len2D_x,len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x,len1D_x,2len1D_x,3len1D_x,4len1D_x" from_switchpoint="0" to_type="len1_y,len1D_y,2len1D_y,3len1D_y,4len1D_y,len2_y,len6_y,len6_stub,len12_y,len18_y,1len4D_y,2len4D_y,3len4D_y,4len4D_y,1len2D_x,2len2D_x,3len2D_x,4len2D_x,len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x,len1D_x,2len1D_x,3len1D_x,4len1D_x" to_switchpoint="0"/> -->
      <!-- THe above is teribly messy but it gives us a good idea as to what a max will do. can confirm it does connect everything. -->
      <!-- This made things worse. chanel on svision3 is 222 was previusly 208 -->
    </switchblock>

  </switchblocklist>
  <!-- <directlist>
    <direct name="common_clk" from_pin="clb.CLK" to_pin="clb.CLK" x_offset="0" y_offset="1" z_offset="0"/>
  </directlist> -->
  
  <power>
    <local_interconnect C_wire="2.5e-10"/>
    <mux_transistor_size mux_transistor_size="3"/>
    <FF_size FF_size="4"/>
    <LUT_transistor_size LUT_transistor_size="4"/>
  </power>
  <clocks>
    <clock buffer_size="auto" C_wire="2.5e-10"/>
  </clocks>
</architecture>

<!-- !! There is no symbiflow info for DSP's -->

<!-- !! DSPs have there own dedicated SBs that are the length of 2 DSPs put together. However the pips in these SBs only 
!! only connect to one wire each. -->
