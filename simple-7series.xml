<!--
  This architecture file is an approximation of the xilinx 7 series chip set. It's main purpose is to verify VPR's ability to
  accommodate xilinx specific routing (i.e. differing wire lengths and frequencies in the horizontal/vertical directions, differing chanel widths,
  and diagonal wire segments). Given that this architectures primary function is to test xilinx specific routing, the architecture includes only
  a simplified version of the Xilinx CLB that excludes carry logic. f4pga/symbiflow's arch.timing.xml and VTR's k6_N10_40nm.xml were pulled from to create
  this architecture description.

  - 40 nm technology
  - General purpose logic block excluding carry.
  - Routing architecture: fc_in = 0.15, Fc_out = 0.1
;
  Authors: Xan Johnson, Joshua Fife, Jeff Goeders
-->
<architecture>
  <!-- ODIN II specific config begins -->
  <!--
         Given that basic LUTs, I/Os, and flip-flops already have special structures in
     blif (.names, .input, .output, and .latch) that describe them and that this arch
     contains CLB logic blocks only, no special models are needed for this architecture.
    -->
  <models/>
  <tiles>
    <tile name="io" area="0">
      <sub_tile name="io" capacity="8">
        <equivalent_sites>
          <site pb_type="io" pin_mapping="direct"/>
        </equivalent_sites>
        <input name="outpad" num_pins="1"/>
        <output name="inpad" num_pins="1"/>
        <clock name="clock" num_pins="1"/>
        <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10"/>
        <pinlocations pattern="custom">
          <loc side="left">io.outpad io.inpad io.clock</loc>
          <loc side="top">io.outpad io.inpad io.clock</loc>
          <loc side="right">io.outpad io.inpad io.clock</loc>
          <loc side="bottom">io.outpad io.inpad io.clock</loc>
        </pinlocations>
      </sub_tile>
    </tile>
    <tile name="clb">
      <sub_tile capacity="1" name="clb">
        <!-- Sub Tile Inputs -->
        <clock name="CLK" num_pins="1"/>
        <input name="I" num_pins="56"/>
        <output name="O" num_pins="24"/>
        <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10">
          <fc_override port_name="cout" fc_type="frac" fc_val="0"/>
        </fc>
        <equivalent_sites>
          <site pb_type="clb" pin_mapping="direct">
          </site>
        </equivalent_sites>
      </sub_tile>
      <switchblock_locations pattern="all"/>
    </tile>
  </tiles>
  <!-- ODIN II specific config ends -->

  <!-- Physical descriptions begin -->
  <layout>
    <auto_layout aspect_ratio="1.0">
      <!--Perimeter of 'io' blocks with 'EMPTY' blocks at corners-->
      <perimeter type="io" priority="100"/>
      <corners type="EMPTY" priority="101"/>
      <!--Fill with 'clb'-->
      <fill type="clb" priority="10"/>
    </auto_layout>
  </layout>
  <device>
   <!-- The  values bellow (sizing and area) are pulled from the k6_N10_40nm arch. -->
    <sizing R_minW_nmos="8926" R_minW_pmos="16067"/>
    <area grid_logic_tile_area="0"/>

    <chan_width_distr>
      <x distr="uniform" peak="1.000000"/>
      <y distr="uniform" peak="1.000000"/>
    </chan_width_distr>
    <switch_block type="custom"/>
    <connection_block input_switch_name="ipin_cblock"/>
  </device>

  <switchlist>

    <!--the following muxes for unidirectional wires are pulled from k6_N10_40nm -->
    <switch type="mux" name="0" R="551" Cin=".77e-15" Cout="4e-15" Tdel="58e-12" mux_trans_size="2.630740" buf_size="27.645901"/>
    <switch type="mux" name="ipin_cblock" R="2231.5" Cout="0." Cin="1.47e-15" Tdel="7.247000e-11" mux_trans_size="1.222260" buf_size="auto"/>
    <switch type="short" name="electrical_short2" R="0" Cin="0" Tdel="0"/>
  </switchlist>

  <segmentlist>
        <!--- The following segment data is pulled from Table 1 of the NetCraker paper by Morten B. Petersen,
    Stefan Nikolić and Mirjana Stojilović: see https://dl.acm.org/doi/10.1145/3431920.3439285. Frequencies
    are calculated by dividing each wire segments count in the horizontal/vertical direction
    by the total width/hight of the architecture -->

    <!-- TODO: To more accurately approximate the seven series, support for both unidirectional and
    bidirectional segments within the same segmentlist is needed. For now we declare all segments as
    unidirectional -->

    <!-- TODO: For proper timing, Xilinx specific values for Rmetal and Cmetal are required.
    For now we approximate using the values given in the k6_N10_40nm arch -->

        <segment axis="x" name="len1_x" freq="0.112903" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 1</sb>
            <cb type="pattern">1</cb>
        </segment>
        <segment axis="y" name="len1_y" freq="0.073684" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 1</sb>
            <cb type="pattern">1</cb>
        </segment>

        <segment axis="x" name="len2_x" freq="0.129031" length="2" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 1</sb>
            <cb type="pattern">1 1</cb>
        </segment>

        <segment axis="y" name="len2_y" freq="0.084210" length="2" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 1</sb>
            <cb type="pattern">1 1</cb>
        </segment>

        <segment axis="x" name="len4_x" freq="0.225807" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 0 0 1</sb>
            <cb type="pattern">1 0 0 1</cb>
        </segment>
        <segment axis="y" name="len4D_y" freq="0" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
          <mux name="0"/>
          <sb type="pattern">1 0 0 0 1</sb>
          <cb type="pattern">1 0 0 1</cb>
        </segment>


    <!-- 12.5% of horizontal len4 wires have the following unique sb pattern -->
    <segment axis="x" name="len4_stub" freq="0.032258" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 1 0 1</sb>
            <cb type="pattern">1 0 0 1</cb>
        </segment>


        <!-- No length 6 horizontal chanels -->
    <!-- VPR throws an error if this segment in the x direction with zero frequency is not included -->
    <segment axis="x" name="len6_x" freq="0.000000" length="6" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 0 0 0 0 1</sb>
            <cb type="pattern">1 0 0 0 0 1</cb>
        </segment>
        <segment axis="y" name="len6_y" freq="0.189475" length="6" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 0 0 0 0 1</sb>
            <cb type="pattern">1 0 0 0 0 1</cb>
        </segment>

    <!-- 25% of len6 vertical wires have a unique sb pattern -->
    <segment axis="y" name="len6_stub" freq="0.063158" length="6" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 1 0 0 0 0 1</sb>
            <cb type="pattern">1 0 0 0 0 1</cb>
        </segment>

    <!-- TODO: In xilinx length 12 and 18 wires are bidirectional -->

    <segment axis="x" name="len12_x" freq="0.096774" length="12" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
            <sb type="pattern">1 0 0 0 0 0 0 0 0 0 0 0 1</sb>
            <cb type="pattern">1 0 0 0 0 0 0 0 0 0 0 1</cb>
        </segment>
        <segment axis="y" name="len12_y" freq="0.063158" length="12" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 0 0 0 0 0 0 0 0 0 0 1</sb>
            <cb type="pattern">1 0 0 0 0 0 0 0 0 0 0 1</cb>
        </segment>

        <!-- No length 18 horizontal chanel's -->
    <!-- VPR throws an error if this segment in the x direction with zero frequency is not included -->
    <segment axis="x" name="len18_x" freq="0.000000" length="18" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1</sb>
            <cb type="pattern">1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1</cb>
        </segment>

        <segment axis="y" name="len18_y" freq="0.094736" length="18" type="unidir" Rmetal="101" Cmetal="22.5e-15">
            <mux name="0"/>
            <sb type="pattern">1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1</sb>
            <cb type="pattern">1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1</cb>
        </segment>



  <!-- TODO: Support in VPR for diagonal wires is currently in the works.
  Until full support for this feature is implemented, this part of the
  Xilinx routing is excluded. -->

  <!-- all length 4 vertical wires are part of diagonal components. We split the vertical contribution of length 4 
  wires into four separate parts so that all intercardinal directions may be specified without conflict when SB unions occur. 
  The same thing is done to length 2 wires-->
  <segment axis="y" name="1len4D_y" freq="0.084211" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0</cb>
  </segment>
  <segment axis="y" name="2len4D_y" freq="0.084211" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0</cb>
  </segment>
  <segment axis="y" name="3len4D_y" freq="0.084211" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0</cb>
  </segment>
  <segment axis="y" name="4len4D_y" freq="0.084211" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 0 0 1</sb>
      <cb type="pattern">1 0 0 0</cb>
  </segment>

  <!-- length 2 horizontal wires that contribute to diagonal interconnect -->
  <segment axis="x" name="1len2D_x" freq="0.064516" length="2" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 1</sb>
      <cb type="pattern">0 1</cb>
    </segment>
    <segment axis="x" name="2len2D_x" freq="0.064516" length="2" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 1</sb>
      <cb type="pattern">0 1</cb>
    </segment>
    <segment axis="x" name="3len2D_x" freq="0.064516" length="2" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 1</sb>
      <cb type="pattern">1 0</cb>
    </segment>
    <segment axis="x" name="4len2D_x" freq="0.064516" length="2" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 0 1</sb>
      <cb type="pattern">1 0</cb>
    </segment>

    <!-- L1->L1 diagonals -->
    <segment axis="y" name="len1D_y" freq="0.023684" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
  </segment>
  <segment axis="y" name="2len1D_y" freq="0.023684" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
      <mux name="0"/>
      <sb type="pattern">1 1</sb>
      <cb type="pattern">1</cb>
  </segment>
  <segment axis="y" name="3len1D_y" freq="0.023684" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
    <mux name="0"/>
    <sb type="pattern">1 1</sb>
    <cb type="pattern">1</cb>
</segment>
<segment axis="y" name="4len1D_y" freq="0.023684" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
    <mux name="0"/>
    <sb type="pattern">1 1</sb>
    <cb type="pattern">1</cb>
</segment>

  <segment axis="x" name="len1D_x" freq="0.036290" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
    <mux name="0"/>
    <sb type="pattern">1 1</sb>
    <cb type="pattern">1</cb>
</segment>
<segment axis="x" name="2len1D_x" freq="0.036290" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
    <mux name="0"/>
    <sb type="pattern">1 1</sb>
    <cb type="pattern">1</cb>
</segment>
<segment axis="x" name="3len1D_x" freq="0.036290" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
  <mux name="0"/>
  <sb type="pattern">1 1</sb>
  <cb type="pattern">1</cb>
</segment>
<segment axis="x" name="4len1D_x" freq="0.036290" length="1" type="unidir" Rmetal="101" Cmetal="22.5e-15">
  <mux name="0"/>
  <sb type="pattern">1 1</sb>
  <cb type="pattern">1</cb>
</segment>

<!--!!! BUG: If you misspell axsis nothing happens (no error)  -->

    </segmentlist>
  <complexblocklist>
    <!-- Define I/O pads begin -->
    <!-- The structure of the IO from the k6_N10_40nm arch is
    used here to approximate the seven series IO. Timing values
    are changed to match the seven series.-->
    <pb_type name="io">
      <input name="outpad" num_pins="1"/>
      <output name="inpad" num_pins="1"/>
      <clock name="clock" num_pins="1"/>
      <!-- IOs can operate as either inputs or outputs.
           Delays below are pulled from the IOBUF description
       in f4pga/symbiflow's arch.timing.xml
           -->
      <mode name="inpad">
        <pb_type name="inpad" blif_model=".input" num_pb="1">
          <output name="inpad" num_pins="1"/>
        </pb_type>
        <interconnect>
          <direct name="inpad" input="inpad.inpad" output="io.inpad">
          <!-- delay bellow is pulled from f4pga/symbiflow's arch.timing architecture -->
            <delay_constant max="10e-12" in_port="inpad.inpad" out_port="io.inpad"/>
          </direct>
        </interconnect>
      </mode>
      <mode name="outpad">
        <pb_type name="outpad" blif_model=".output" num_pb="1">
          <input name="outpad" num_pins="1"/>
        </pb_type>
        <interconnect>
          <direct name="outpad" input="io.outpad" output="outpad.outpad">
          <!-- delay bellow is pulled from f4pga/symbiflow's arch.timing architecture -->
            <delay_constant max="10e-12" in_port="io.outpad" out_port="outpad.outpad"/>
          </direct>
        </interconnect>
      </mode>
      <!-- Every input pin is driven by 15% of the tracks in a channel, every output pin is driven by 10% of the tracks in a channel -->
      <!-- IOs go on the periphery of the FPGA, for consistency,
            make it physically equivalent on all sides so that only one definition of I/Os is needed.
          -->
      <!-- Place I/Os on the sides of the FPGA -->
      <power method="ignore"/>
    </pb_type>
    <!-- Define I/O pads ends -->

    <pb_type name="clb">
      <clock name="CLK" num_pins="1"/>
      <input name="I" num_pins="56"/>
      <output name="O" num_pins="24"/>
      <pb_type name="slice" num_pb="2">
        <clock name="CLK" num_pins="1"/>
        <input name="I" num_pins="28" />
        <output name="O" num_pins="12"/>
        <pb_type name="fle" num_pb="4">
          <input name="in" num_pins="6"/>
          <input name="inX" num_pins="1"/>
          <output name="out" num_pins="1"/>
          <output name="outMUX" num_pins="1"/>
          <output name="outQ" num_pins="1"/>
          <clock name="clk" num_pins="1"/>
          <pb_type name="ALUT" num_pb="1">
            <input name="A" num_pins="6"/>
            <output name="O5" num_pins="1"/>
            <output name="O6" num_pins="1"/>
            <mode name="n2_lut5">
              <pb_type name="lut5_mode" num_pb="1">
                <input name="in" num_pins="5"/>
                <output name="out" num_pins="1"/>
                <pb_type name="lut5" blif_model=".names" num_pb="1" class="lut">
                  <input name="in" num_pins="5" port_class="lut_in"/>
                  <output name="out" num_pins="1" port_class="lut_out"/>
                  <!-- LUT timing using delay matrix -->
                  <!-- These are the physical delay inputs on a seven series LUT. These values are pulled from f4pga/symbiflow's arch file-->
                  <delay_matrix in_port="lut5.in" out_port="lut5.out" type="max">
                  1.5200000000000002e-10
                  1.5200000000000002e-10
                  1.5e-10
                  1.5e-10
                  1.18e-10
                  </delay_matrix>
                  <delay_matrix in_port="lut5.in" out_port="lut5.out" type="min">
                  4.4e-11
                  4.4e-11
                  4.2000000000000004e-11
                  4.6e-11
                  4.8e-11
                  </delay_matrix>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="lut5_mode.in" output="lut5.in"/>
                  <direct name="direct2" input="lut5.out" output="lut5_mode.out"/>
                </interconnect>
              </pb_type>
              <interconnect>
                <direct name="direct1" input="ALUT.A[4:0]" output="lut5_mode.in"/>
                <direct name="direct3" input="lut5_mode.out" output="ALUT.O5"/>
              </interconnect>
            </mode>
            <mode name="n1_lut6">
              <pb_type name="lut6_mode" num_pb="1">
                <input name="in" num_pins="6"/>
                <output name="out" num_pins="1"/>
                <pb_type name="lut6" blif_model=".names" num_pb="1" class="lut">
                  <input name="in" num_pins="6" port_class="lut_in"/>
                  <output name="out" num_pins="1" port_class="lut_out"/>
                  <!-- LUT timing using delay matrix -->
                  <!-- These are the physical delay inputs on a seven series LUT. These values are pulled from f4pga/symbiflow's arch file-->
                  <delay_matrix in_port="lut6.in" out_port="lut6.out" type="max">
                  1.6200000000000002e-10
                  1.6200000000000002e-10
                  1.6e-10
                  1.6e-10
                  1.6e-10
                  1.28e-10
                  </delay_matrix>
                  <delay_matrix in_port="lut6.in" out_port="lut6.out" type="min">
                  4.4e-11
                  4.4e-11
                  4.2000000000000004e-11
                  4.6e-11
                  4.5e-11
                  4.8e-11
                  </delay_matrix>
                </pb_type>
                <interconnect>
                  <direct name="direct1" input="lut6_mode.in" output="lut6.in"/>
                  <direct name="direct2" input="lut6.out" output="lut6_mode.out"/>
                </interconnect>
              </pb_type>
              <interconnect>
                <direct name="direct1" input="ALUT.A" output="lut6_mode.in"/>
                <direct name="direct2" input="lut6_mode.out" output="ALUT.O6"/>
              </interconnect>
            </mode>
          </pb_type>

          <pb_type blif_model=".latch" name="FDSE" num_pb="2" class="flipflop">
            <clock name="clk" num_pins="1" port_class="clock"/>
            <input name="D" num_pins="1" port_class="D"/>
            <output name="Q" num_pins="1" port_class="Q"/>
            <T_setup clock="clk" port="FDSE.D" value="-4.6e-11"/>
            <T_hold clock="clk" port="FDSE.D" value="1.81e-10"/>
            <T_clock_to_Q clock="clk" max="3.03e-10" port="FDSE.Q" min="9.900000000000001e-11"/>
          </pb_type>
          <!-- The following interconnect matches that of the seven series.
          Delays are pulled from the f4pga/symbiflow arch -->
          <interconnect>
            <mux name="AOUTMUX" input="ALUT.O5 ALUT.O6 FDSE[0].Q" output="fle.outMUX">
              <delay_constant in_port="FDSE[0].Q" max="1.73e-10" out_port="fle.outMUX"/>
              <delay_constant in_port="ALUT[0].O6" max="2.05e-10" out_port="fle.outMUX"/>
              <delay_constant in_port="ALUT[0].O5" max="2.0300000000000002e-10" out_port="fle.outMUX"/>
            </mux>
            <mux name="FFMUX" input="ALUT.O5 fle.inX" output="FDSE[0].D">
              <delay_constant in_port="fle.inX" max="2.0200000000000003e-10" out_port="FDSE[0].D"/>
                        <delay_constant in_port="ALUT.O5" max="1.07e-10" out_port="FDSE[0].D"/>
            </mux>
            <mux name="A5FFMUX" input="ALUT.O5 ALUT.O6 fle.inX" output="FDSE[1].D">
              <delay_constant in_port="fle.inX" max="2.14e-10" out_port="FDSE[1].D"/>
              <delay_constant in_port="ALUT.O5" max="9.6e-11" out_port="FDSE[1].D"/>
              <delay_constant in_port="ALUT.O6" max="1.07e-10" out_port="FDSE[1].D"/>
            </mux>
            <direct name="inputs" input="fle.in" output="ALUT.A"/>
            <direct name="outA" input="ALUT.O6" output="fle.out"/>
            <direct name="outQ" input="FDSE[1].Q" output="fle.outQ"/>
            <complete name="clocks" input="fle.clk" output="FDSE[1:0].clk"/>
          </interconnect>
        </pb_type>

        <interconnect>
          <complete input="slice.CLK" name="CK" output="fle.clk"/>
          <direct name="dir1" input="fle[0].outMUX" output="slice.O[0]"/>
          <direct name="dir2" input="fle[0].out" output="slice.O[1]"/>
          <direct name="dir3" input="fle[0].outQ" output="slice.O[2]"/>
          <direct name="dir4" input="fle[1].outMUX" output="slice.O[3]"/>
          <direct name="dir5" input="fle[1].out" output="slice.O[4]"/>
          <direct name="dir6" input="fle[1].outQ" output="slice.O[5]"/>
          <direct name="dir7" input="fle[2].outMUX" output="slice.O[6]"/>
          <direct name="dir8" input="fle[2].out" output="slice.O[7]"/>
          <direct name="dir9" input="fle[2].outQ" output="slice.O[8]"/>
          <direct name="dir10" input="fle[3].outMUX" output="slice.O[9]"/>
          <direct name="dir11" input="fle[3].out" output="slice.O[10]"/>
          <direct name="dir12" input="fle[3].outQ" output="slice.O[11]"/>
          <direct name="inA" input="slice.I[5:0]" output="fle[0].in"/>
          <direct name="inB" input="slice.I[12:7]" output="fle[1].in"/>
          <direct name="inC" input="slice.I[19:14]" output="fle[2].in"/>
          <direct name="inD" input="slice.I[26:21]" output="fle[3].in"/>
        </interconnect>
      </pb_type>
      <!-- Partial Crossbar with each input to the slice connected to 3 outputs from the same slice.
      Values are taken from prjxray-db/artix7/tile_int_l -->
      <interconnect>
        <direct name="top_slice" input="clb.I[27:0]" output="slice[0].I"/>
        <direct name="bottom_slice" input="clb.I[55:28]" output="slice[1].I"/>
        <direct name="top_slice_O" input="slice[0].O" output="clb.O[0:11]"/>
        <direct name="bottom_slice_O" input="slice[1].O" output="clb.O[12:23]"/>
        <complete name="CLK" input="clb.CLK" output="slice.CLK"/>
        <complete name="cross0" input="slice[0].O[6] slice[0].O[1] slice[1].O[2]" output="slice[1].I[2]"/>
        <complete name="cross1" input="slice[1].O[6] slice[1].O[1] slice[0].O[2]" output="slice[0].I[2]"/>
        <complete name="cross2" input="slice[1].O[9] slice[1].O[4] slice[0].O[5]" output="slice[0].I[1]"/>
        <complete name="cross3" input="slice[0].O[9] slice[0].O[4] slice[1].O[5]" output="slice[1].I[1]"/>
        <complete name="cross4" input="slice[0].O[0] slice[0].O[7] slice[1].O[8]" output="slice[0].I[5]"/>
        <complete name="cross5" input="slice[1].O[0] slice[1].O[7] slice[0].O[8]" output="slice[1].I[5]"/>
        <complete name="cross6" input="slice[1].O[3] slice[1].O[10] slice[0].O[11]" output="slice[1].I[0]"/>
        <complete name="cross7" input="slice[0].O[3] slice[0].O[10] slice[1].O[11]" output="slice[0].I[1]"/>
        <complete name="cross8" input="slice[0].O[6] slice[1].O[2] slice[0].O[1]" output="slice[0].I[4]"/>
        <complete name="cross9" input="slice[1].O[6] slice[0].O[2] slice[1].O[1]" output="slice[1].I[4]"/>
        <complete name="cross10" input="slice[1].O[9] slice[0].O[5] slice[1].O[4]" output="slice[1].I[3]"/>
        <complete name="cross11" input="slice[0].O[9] slice[1].O[5] slice[0].O[4]" output="slice[0].I[3]"/>
        <complete name="cross12" input="slice[0].O[0] slice[1].O[8] slice[0].O[7]" output="slice[0].I[12]"/>
        <complete name="cross13" input="slice[1].O[0] slice[0].O[8] slice[1].O[7]" output="slice[0].I[12]"/>
        <complete name="cross14" input="slice[1].O[3] slice[0].O[11] slice[1].O[10]" output="slice[1].I[7]"/>
        <complete name="cross15" input="slice[0].O[3] slice[1].O[11] slice[0].O[10]" output="slice[0].I[7]"/>
        <complete name="cross16" input="slice[0].O[6] slice[0].O[1] slice[1].O[2]" output="slice[1].I[9]"/>
        <complete name="cross17" input="slice[1].O[6] slice[1].O[1] slice[0].O[2]" output="slice[0].I[9]"/>
        <complete name="cross18" input="slice[1].O[9] slice[1].O[4] slice[0].O[5]" output="slice[0].I[8]"/>
        <complete name="cross19" input="slice[0].O[9] slice[0].O[4] slice[1].O[5]" output="slice[1].I[8]"/>
        <complete name="cross20" input="slice[0].O[0] slice[0].O[7] slice[1].O[8]" output="slice[1].I[15]"/>
        <complete name="cross21" input="slice[1].O[0] slice[1].O[7] slice[0].O[8]" output="slice[1].I[17]"/>
        <complete name="cross22" input="slice[1].O[3] slice[1].O[10] slice[0].O[11]" output="slice[0].I[16]"/>
        <complete name="cross23" input="slice[0].O[3] slice[0].O[10] slice[1].O[11]" output="slice[1].I[16]"/>
        <complete name="cross24" input="slice[0].O[6] slice[1].O[2] slice[0].O[1]" output="slice[0].I[11]"/>
        <complete name="cross25" input="slice[1].O[6] slice[0].O[2] slice[1].O[1]" output="slice[1].I[11]"/>
        <complete name="cross26" input="slice[1].O[9] slice[0].O[5] slice[1].O[4]" output="slice[1].I[10]"/>
        <complete name="cross27" input="slice[0].O[9] slice[1].O[5] slice[0].O[4]" output="slice[0].I[10]"/>
        <complete name="cross28" input="slice[0].O[0] slice[1].O[8] slice[0].O[7]" output="slice[0].I[17]"/>
        <complete name="cross29" input="slice[1].O[0] slice[0].O[8] slice[1].O[7]" output="slice[0].I[15]"/>
        <complete name="cross30" input="slice[1].O[3] slice[0].O[11] slice[1].O[10]" output="slice[1].I[18]"/>
        <complete name="cross31" input="slice[0].O[3] slice[1].O[11] slice[0].O[10]" output="slice[0].I[18]"/>
        <complete name="cross32" input="slice[0].O[6] slice[0].O[1] slice[1].O[2]" output="slice[0].I[14]"/>
        <complete name="cross33" input="slice[1].O[6] slice[1].O[1] slice[0].O[2]" output="slice[1].I[14]"/>
        <complete name="cross34" input="slice[1].O[9] slice[1].O[4] slice[0].O[5]" output="slice[1].I[19]"/>
        <complete name="cross35" input="slice[0].O[9] slice[0].O[4] slice[1].O[5]" output="slice[0].I[19]"/>
        <complete name="cross36" input="slice[0].O[0] slice[0].O[7] slice[1].O[8]" output="slice[1].I[22]"/>
        <complete name="cross37" input="slice[1].O[0] slice[1].O[7] slice[0].O[8]" output="slice[1].I[24]"/>
        <complete name="cross38" input="slice[1].O[3] slice[1].O[10] slice[0].O[11]" output="slice[0].I[23]"/>
        <complete name="cross39" input="slice[0].O[3] slice[0].O[10] slice[1].O[11]" output="slice[1].I[23]"/>
        <complete name="cross40" input="slice[0].O[6] slice[1].O[2] slice[0].O[1]" output="slice[0].I[21]"/>
        <complete name="cross41" input="slice[1].O[6] slice[0].O[2] slice[1].O[1]" output="slice[1].I[21]"/>
        <complete name="cross42" input="slice[1].O[9] slice[0].O[5] slice[1].O[4]" output="slice[1].I[26]"/>
        <complete name="cross43" input="slice[0].O[9] slice[1].O[5] slice[0].O[4]" output="slice[0].I[26]"/>
        <complete name="cross44" input="slice[0].O[0] slice[1].O[8] slice[0].O[7]" output="slice[0].I[24]"/>
        <complete name="cross45" input="slice[1].O[0] slice[0].O[8] slice[1].O[7]" output="slice[0].I[22]"/>
        <complete name="cross46" input="slice[1].O[3] slice[0].O[11] slice[1].O[10]" output="slice[1].I[25]"/>
        <complete name="cross47" input="slice[0].O[3] slice[1].O[11] slice[0].O[10]" output="slice[0].I[25]"/>
      </interconnect>
    </pb_type>
    <!-- Define general purpose logic block (CLB) ends -->
  </complexblocklist>
  <!-- TODO: Custom SB's and independent wire distributions in the x/y direction are not fully supported yet. 
    After this full support becomes available, a better capture of the xilinx wire interconnect can be achieved.   -->
   
    
    <switchblocklist>
      <!-- custom SBs used to create diagonal wires -->
      <switchblock name="diagonal_cw_turns" type="unidir">
          <switchblock_location type="EVERYWHERE"/>
          <switchfuncs>
            <!-- Clock-wise turns -->
            <func type="tl" formula="W-t"/>
            <!-- top to left -->
            <func type="rt" formula="t+1"/>
            <!-- right to top -->
            <func type="br" formula="2*W-2-t"/>
            <!-- bottom to right -->
            <func type="lb" formula="t+1"/>
            <!-- left to bottom -->
          </switchfuncs>
          <wireconn num_conns="min(from,to)" from_type="1len4D_y" from_switchpoint="0" to_type="1len2D_x" to_switchpoint="0" switch_override="electrical_short2"/>  <!-- technichly we could do diagonal wires by just creating a switch override in side wireconn -->
          <wireconn num_conns="min(from,to)" from_type="3len2D_x" from_switchpoint="0" to_type="3len4D_y" to_switchpoint="0" switch_override="electrical_short2"/>\
          <wireconn num_conns="min(from,to)" from_type="len1D_y" from_switchpoint="0" to_type="len1D_x" to_switchpoint="0" switch_override="electrical_short2"/>
          <wireconn num_conns="min(from,to)" from_type="3len1D_x" from_switchpoint="0" to_type="3len1D_y" to_switchpoint="0" switch_override="electrical_short2"/>
      </switchblock>

      <switchblock name="diagonal_ccw_turns" type="unidir">
          <switchblock_location type="EVERYWHERE"/>
          <switchfuncs>
              <func type="lt" formula="W-t"/>
              <func type="tr" formula="t+1"/>
              <func type="rb" formula="2*W-2-t"/>
              <func type="bl" formula="t+1"/>
          </switchfuncs>
          <wireconn num_conns="min(from,to)" from_type="2len4D_y" from_switchpoint="0" to_type="2len2D_x" to_switchpoint="0" switch_override="electrical_short2"/>
          <wireconn num_conns="min(from,to)" from_type="4len2D_x" from_switchpoint="0" to_type="4len4D_y" to_switchpoint="0" switch_override="electrical_short2"/>
          <wireconn num_conns="min(from,to)" from_type="2len1D_y" from_switchpoint="0" to_type="2len1D_x" to_switchpoint="0" switch_override="electrical_short2"/>
          <wireconn num_conns="min(from,to)" from_type="4len1D_x" from_switchpoint="0" to_type="4len1D_y" to_switchpoint="0" switch_override="electrical_short2"/>
      </switchblock>
      <!-- End custom SBs used to create diagonal wires --> 

      <!-- Normal interconnect (following wilton typology for now) -->
      <switchblock name="normal_x" type="unidir">
        <switchblock_location type="EVERYWHERE"/>
        <switchfuncs>
           <!-- Clock-wise turns -->
            <func type="rt" formula="W-t"/>
            <!-- top to left -->
            <func type="rb" formula="t+1"/>
            <!-- right to top -->
            <func type="lt" formula="2*W-2-t"/>
            <!-- bottom to right -->
            <func type="lb" formula="t+1"/>
            <!-- left to bottom -->
            <func type="lr" formula="t"/>
            <!-- bottom to right -->
            <func type="rl" formula="t"/>
            <!-- left to bottom -->
        </switchfuncs>
        <!-- !! what replaces dummy wire x: len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x -->
        <!-- !! what replaces dummy wire y: len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y -->
        <wireconn num_conns="min(from,to)" from_type="1len2D_x,2len2D_x,len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x" from_switchpoint="0" to_type="len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,2len4D_y" to_switchpoint="0"/>
        <wireconn num_conns="min(from,to)" from_type="len4_stub" from_switchpoint="2" to_type="len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x,1len4D_y,len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,2len4D_y" to_switchpoint="0"/>
      </switchblock>

    <switchblock name="normal_y" type="unidir">
      <switchblock_location type="EVERYWHERE"/>
      <switchfuncs>
         <!-- Clock-wise turns -->
          <func type="tr" formula="W-t"/>
          <!-- top to left -->
          <func type="tl" formula="t+1"/>
          <!-- right to top -->
          <func type="br" formula="2*W-2-t"/>
          <!-- bottom to right -->
          <func type="bl" formula="t+1"/>
          <!-- left to bottom -->
          <func type="tb" formula="t"/>
          <!-- bottom to right -->
          <func type="bt" formula="t"/>
          <!-- left to bottom -->
      </switchfuncs>
      <wireconn num_conns="min(from,to)" from_type="3len4D_y,4len4D_y,len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y" from_switchpoint="0" to_type="len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,3len2D_x,4len2D_x,len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x" to_switchpoint="0"/>
      <wireconn num_conns="min(from,to)" from_type="len6_stub" from_switchpoint="1" to_type="len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y,3len2D_x,4len2D_x,len1_x,len2_x,len4_x,len4_stub,len12_x,len18_x" to_switchpoint="0"/>
    </switchblock>

    <switchblock name="fringe" type="unidir">
      <switchblock_location type="FRINGE"/>
      <switchfuncs>
         <!-- Clock-wise turns -->
          <func type="bb" formula="W-t"/>
      </switchfuncs>
      <wireconn num_conns="min(from,to)" from_type="3len4D_y,4len4D_y,len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y" from_switchpoint="0" to_type="3len4D_y,4len4D_y,len1_y,len2_y,len6_y,len6_stub,len12_y,len18_y" to_switchpoint="0"/>
    </switchblock>

  </switchblocklist>
  
  <power>
    <local_interconnect C_wire="2.5e-10"/>
    <mux_transistor_size mux_transistor_size="3"/>
    <FF_size FF_size="4"/>
    <LUT_transistor_size LUT_transistor_size="4"/>
  </power>
  <clocks>
    <clock buffer_size="auto" C_wire="2.5e-10"/>
  </clocks>
</architecture>